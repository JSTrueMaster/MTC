import React from "react";
import api from "src/api";
import { ExportToCsv } from 'ts-export-to-csv';
import { ToastContainer, toast } from 'react-toastify';
import { MenuItem, Box, Button, TextField, Select } from "@mui/material";
import * as XLSX from 'xlsx';

// グリッドモジュールのインポート
import {
  IgrDataGrid,
  IgrDataGridModule,
  IgrDataGridToolbar,
  IgrDataBindingEventArgs,
  IgrDataGridToolbarModule,
  IgrGridColumnOptionsModule,
  IgrTemplateCellUpdatingEventArgs,
  IgrGridActiveCellChangedEventArgs,
  IgrGridCellValueChangingEventArgs,

  IgrTextColumn,
  IgrComboBoxColumn,
  IgrDateTimeColumn,
  IgrNumericColumn,
  IgrTemplateColumn,
  IgrImageColumn,
  IgrTemplateCellInfo,
  IgrDataGridColumn,
  IIgrCellTemplateProps,
  HeaderClickAction,
  IgrTemplateHeader,
  IgrTemplateHeaderCellUpdatingEventArgs,
  IgrGridColumnsAutoGeneratedEventArgs,
} from 'igniteui-react-grids';


// importing localization data:
import { Localization } from 'igniteui-react-core';
import { DataGridLocalizationJa, DataGridSummariesLocalizationJa, DataGridDateTimeColumnLocalizationJa, DataGridMultiColumnComboBoxLocalizationJa } from 'src/constants/DataGridLocaleJa';

// register() メソッドの実行
IgrDataGridModule.register();
IgrDataGridToolbarModule.register();
IgrGridColumnOptionsModule.register();


export default class DiffTable extends React.Component<any, any> {

  public grid: IgrDataGrid;
  public toolbar: IgrDataGridToolbar;
  public DiffHeader: IgrTemplateHeader;
  //const of style
  public defaultColumnMinWidth = 150
  public imgColumnWidth = 300
  public cornerRadius = 8
  public rowHeight = 40

  public data = [] as any
  public resData = {} as any;
  private mergepointer = 0;

  constructor(props: any) {

    super(props);

    
    this.state = {
      data: [],
      loading: true,
      storeName: props.storeName == '' ? localStorage.getItem('storeName').split(",")[0] : props.storeName,
    }
    
    this.onGetData()

    this.DiffHeader = new IgrTemplateHeader({});
    this.DiffHeader.cellUpdating = (s, e) => this.onDiffHeaderUpdating(s, e);

    Localization.register("DataGrid-en", new DataGridLocalizationJa());
    Localization.register("DataVisualization-en", new DataGridSummariesLocalizationJa());
    Localization.register("Calendar-en", new DataGridDateTimeColumnLocalizationJa());
    Localization.register("MultiColumnComboBox-en", new DataGridMultiColumnComboBoxLocalizationJa());
  }

  componentDidUpdate(prevProps: any) {

    if (this.props.storeName !== prevProps.storeName) {
      // Perform any actions you need when storeName changes
      this.setState({ storeName: this.props.storeName });
      setTimeout(() => {
                
        this.data = []
        this.resData = {};
        this.mergepointer = 0;

        this.onGetData();
      }, 500);
    }
  }

  //get data
  public async onGetData(): Promise<void> {
    
    let temp = await api.store.getDiff({
      storeName: this.state.storeName
    })

    temp = temp.data.data
    const step = 6
    const last = temp.salesFee.length;
    temp.卸先.push('計')
    this.resData = temp
    const 卸先 = temp.卸先

    卸先.forEach((element: any) => {
      let subkey = {} as any
      subkey['分類'] = element; this.data.push(subkey)
    })

    for (let index = 0; index < last; index += step) {
      const lastposition = ((index + step) > last) ? last : (index + step);
      await this.showTable({ position: index, last: lastposition });
      this.setState({ data: this.data, loading: false })
    }
  }

  public async showTable({ position, last }: { position: number; last: number; }): Promise<boolean> {
    return new Promise((resolve) => {
      setTimeout(() => {
        const res = this.resData
        const salesFee = res.salesFee
        const cfsFee = res.cfsFee
        const 卸先 = res.卸先
        for (let index1 = position; index1 < last; index1++) {
          const total = {} as any;
          for (let index = 0; index < 卸先.length - 1; index++) {
            const obj = {} as any
            const salefee = salesFee[index1];

            const saleKey = salefee['year'] + '年' + salefee['month'] + '月売上表'            
            const cfKey = salefee['year'] + '年' + salefee['month'] + '月cf'
            const subKey = salefee['year'] + '年' + salefee['month'] + '月差異'

            obj[`${saleKey}`] = 0
            obj[`${cfKey}`] = 0
            obj[`${subKey}`] = 0

            salefee.results.forEach((item: any, index2: number) => {
              if (item.item == 卸先[index]) {
                obj[`${saleKey}`] = item.netRevenue || 0
                obj[`${cfKey}`] = cfsFee[index1]?.results[index2].netRevenue || 0
                obj[`${subKey}`] = obj[`${saleKey}`] - obj[`${cfKey}`] || 0
              }
              if (total[`${saleKey}`] == null) total[`${saleKey}`] = 0
              if (total[`${cfKey}`] == null) total[`${cfKey}`] = 0

            })
            total[`${saleKey}`] += obj[`${saleKey}`]
            total[`${cfKey}`] += obj[`${cfKey}`]
            total[`${subKey}`] = total[`${saleKey}`] - total[`${cfKey}`] || 0
            this.data[index] = { ...this.data[index], ...obj }
            delete this.data[index].$hashCode
          }
          this.data[卸先.length - 1] = { ...this.data[卸先.length - 1], ...total }
          if (salesFee.length == last) this.grid.pinnedItems.add(this.data[卸先.length - 1])
        }
        resolve(true)
      }, 500);
    });
  }

  //render
  public render(): JSX.Element {

    return (
      <>
        <ToastContainer
          position="top-right"
          autoClose={5000}
          hideProgressBar={false}
          newestOnTop={false}
          closeOnClick
          rtl={false}
          pauseOnFocusLoss
          draggable
          pauseOnHover
          theme="light"
        />
        {this.state.loading && <div className="loading" />}
        <div className="gird-container h-full">
          {/* Header Button */}
          <Box className="flex flex-row justify-end">
            <IgrDataGridToolbar ref={this.onToolbarRef} columnChooser="true" />
            <Button component="span" sx={{
              minWidth: 160,
              height: 34,
              color: '#fff !important',
              ":hover": {
                color: '#000 !important',
              },
              fontFamily: 'Meiryo',
              background: '#0066FF',
              border: 1,
              borderColor: '#24BFF2',
              borderRadius: 22,
              boxShadow: '2px 2px 4px rgba(0, 0, 0, 0.2)',
              marginRight: 0.5,
            }}
              onClick={(event) => {
                event.preventDefault()
                this.onExportCSV("卸先別差異確認表")
              }}>
              Excelダウンロード
            </Button>
          </Box>

          <div className="igr-table h-full">
            {/* Table */}
            <IgrDataGrid
              ref={this.onGridRef}
              dataSource={this.state.data}

              editMode={0}
              summaryScope={'none'}
              editOnKeyPress={false}
              filterUIType="FilterRow"      //FILTER
              columnMovingMode={'none'}     //MOVE
              headerClickAction={'none'}    //SORT
              selectionMode="MultipleRow"
              autoGenerateColumns="false"   //AUTO COLUMN
              isColumnOptionsEnabled="true"
              groupHeaderDisplayMode="Combined"
              columnsAutoGenerated={this.onColumnsAutoGenerated}

              cornerRadiusTopRight={this.cornerRadius}
              cornerRadiusTopLeft={this.cornerRadius}
              defaultColumnMinWidth={150}
              rowHeight={this.rowHeight}

              pinnedRowBackground="#E6E6E6"
              headerBackground="#E6E6E6"
              headerTextColor="#4D4D4D"
              headerTextStyle="Meiryo"
              headerHeight={50}
              height="calc(100% - 40px)"
              width="100%"
            >
              <IgrTextColumn field="分類" isEditable={false} pinned={'left'} dataBound={this.onCellDataBound} />

              {this.renderDiffColumns()}

            </IgrDataGrid>
          </div>
        </div>
      </>
    );
  }

  //IgrDataGrid methods
  public onGridRef = (grid: IgrDataGrid) => {
    if (!grid) { return; }

    this.grid = grid;
    if (!this.grid) {
      return;
    }

    if (this.toolbar !== null) {
      this.toolbar.targetGrid = this.grid;
    }
  }

  public onToolbarRef = (toolbar: IgrDataGridToolbar) => {
    this.toolbar = toolbar;
    if (this.toolbar !== null) {
      this.toolbar.targetGrid = this.grid;
    }
  }

  public onColumnsAutoGenerated = (s: IgrDataGrid, e: IgrGridColumnsAutoGeneratedEventArgs) => {

    const columnsArray = Array.from(e.columns);
    columnsArray.forEach((column: any) => {

      column.showGroupingSeparator = true
      column.positivePrefix = "¥"

    });

  }

  //diffColumns
  public renderDiffColumns(): JSX.Element[] {

    const data = this.state.data[0]

    const columns: JSX.Element[] = [];

    for (const key in data) {
      if (key != '分類') {
        columns.push(this.renderColumn(key))
      }
    }

    return columns;
  }

  public renderColumn(field: string) {

    return <IgrTemplateColumn
      width={'100'}
      field={field}
      header={this.DiffHeader}
      dataBound={this.onCellDataBound}
      cellUpdating={this.onDiffCellUpdating}
      key={field}
    />;
  }

  public onDiffHeaderUpdating = (s: IgrTemplateHeader, e: IgrTemplateHeaderCellUpdatingEventArgs) => {

    const content = e.content as HTMLDivElement;
    content.parentElement.style.paddingLeft = '0px';
    content.parentElement.style.paddingRight = '0px';
    content.parentElement.style.lineHeight = 'unset';
    content.parentElement.style.fontFamily = 'Meiryo';

    let month: HTMLSpanElement | null = null;
    let label: HTMLSpanElement | null = null;

    if (content.childElementCount === 0) {
      month = document.createElement("div");
      month.style.height = '25px'
      month.style.display = 'flex'
      month.style.justifyContent = 'center'
      month.style.alignItems = 'center'
      month.style.background = '#babfc7'

      label = document.createElement("div");
      label.style.height = '25px'
      label.style.display = 'flex'
      label.style.fontSize = '12px'
      label.style.justifyContent = 'center'
      label.style.alignItems = 'center'

      content.appendChild(month);
      content.appendChild(label);
    } else {
      month = content.children[0] as HTMLDivElement;
      label = content.children[1] as HTMLDivElement;
    }

    const info = e.cellInfo as IgrTemplateCellInfo;
    const value = info.value

    if (value.indexOf('cf') != -1) {
      month.textContent = value.replace('cf', '');
      label.textContent = 'CF'
    }
    else if (value.indexOf('売上表') != -1) {
      month.style.borderLeftStyle = 'double';
      month.style.borderLeftWidth = '2px'
      month.style.borderLeftColor = 'white'
      label.textContent = '売上表'
    } else {
      // month.style.borderRightStyle = 'double';
      // month.style.borderRightWidth = '2px'
      // month.style.borderRightColor = 'white'
      label.textContent = '差異'
    }

  }

  public onDiffCellUpdating = (s: IgrTemplateColumn, e: IgrTemplateCellUpdatingEventArgs) => {

    const content = e.content as HTMLDivElement;
    const info = e.cellInfo as IgrTemplateCellInfo;

    let diffCell: HTMLDivElement | null = null;

    if (content.childElementCount !== 0) {
      diffCell = content.children[0] as HTMLDivElement;
    } else {
      diffCell = document.createElement("div");
      diffCell.style.color = "black"
      diffCell.style.margin = "0px";
      diffCell.style.padding = "0px";
      diffCell.style.fontSize = "small";
      diffCell.style.textAlign = "right";
      diffCell.style.fontFamily = "Meiryo";

      content.style.margin = "0px";
      content.style.padding = "0px";
      content.appendChild(diffCell);
    }

    diffCell.textContent = '¥' + parseInt(info.value).toLocaleString();
  }

  public onCellDataBound = (s: any, e: IgrDataBindingEventArgs) => {

    if (e.cellInfo.rowItem['分類'] == '計') {
      e.cellInfo.background = "#e6e6e6";
      return;
    }
  }

  //export csv
  public onExportCSV = (t: string) => {
    let data = [] as any

    const mergeRanges = [
      { s: { r: 0, c: 0 }, e: { r: 1, c: 0 } }, // Merge A1:A2
    ];

    this.data.forEach((element: any, index: number) => {
      const arr = [] as any
      const title = [] as any
      const subtitle = [] as any

      Object.entries(element).map(([key, value]) => {
        if (key != '$hashCode') {
          if (index < 2) {
            if (key == "分類") {
              title.push(key)
              subtitle.push(key)
            } else {
              if (typeof key === "string") {
                const num = key.search("月");
                title.push(key.substr(0, num + 1))
                subtitle.push(key.slice(num + 1))
              }
            }
          }
          if (index == 2) {
            if (this.mergepointer % 3 == 0) {
              const pointer = this.mergepointer + 1;
              mergeRanges.push({ s: { r: 0, c: pointer }, e: { r: 0, c: pointer + 2 } })
            }
            this.mergepointer++;
          }
          if (typeof value === 'string') {
            arr.push(value)
          } else {
            // eslint-disable-next-line no-case-declarations
            const v = (typeof value === 'number') ? value : Number(value);
            arr.push(this.currencyFormatter(v))
          }

        }
      })
      if (index == 0) {
        data.push(title)
        data.push(subtitle)
      }
      data.push(arr)
    })

    const worksheet = XLSX.utils.aoa_to_sheet(data);
    // Cast the mergeRanges array to Range[] type
    worksheet['!merges'] = mergeRanges as XLSX.Range[];
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
    XLSX.writeFile(workbook, t + ".xlsx");
  }

  public currencyFormatter = (number: number | bigint) => {
    return new Intl.NumberFormat('en-JP', { style: 'currency', currency: 'JPY' }).format(number)
  }

}

